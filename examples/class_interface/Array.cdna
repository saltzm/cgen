
// Wouldn't necessary if we included it in package.js.dna, but this is just an
// example of how to include other files
./!include("util.js.dna")

// An object to be passed to "defineMetaclass"
var ArrayMetaclass = {
  // This will add Array to a global variable 'mc' (short for metaclass) so
  // that you can declare a new instance as declareClass(mc.Array(t.MyType))
  name: "Array", 
  // This will define a metatype called Array for us so that mt.Array(t.MyType)
  // will return "MyTypeArray"
  instance_name: function(T) { return capitalize(T) + "Array" }
}

// You could just define this in the object above but I'd prefer less
// indentation
ArrayMetaclass.template = function(T) { 
  var ElementArray = ArrayMetaclass.instance_name(T)
  return {
  name: ElementArray,
  struct: { 
    // The size of the array
    size: t.Size,
    // The data in the array
    data: mt.Ptr(T)
  },
  metadata: {
    project_deps: [],
    external_deps: ["assert", "stdio", "stdlib"],
    external_libs: []
  },
  api: {
    Create: {
      inp: { size: t.Size, init_value: T },
      out: mt.Ptr(ElementArray),
      def: () => {
.       @{ElementArray}*self = malloc(sizeof(@{ElementArray}));
.       assert(self);
.       self->size = size;
.       self->data = malloc(self->size * sizeof(@{T}));
.       assert(self->data);
.       for (size_t i = 0; i < self->size; ++i) {
.         self->data[i] = init_value;
.       }
.       return self;
      }
    },
    Destroy: {
      inp: { self_ptr: mt.Ptr(mt.Ptr(ElementArray)) },
      out: t.Nothing,
      def: () => {
.       assert(self_ptr);
.       assert(*self_ptr);
.       @{ElementArray}* self = *self_ptr;
.       free(self->data);
.       free(self);
.       *self_ptr = NULL;
      }
    },
    GetSize: {
      inp: { self: mt.Ptr(ElementArray) },
      out: t.Size,
      def: () => {
.       return self->size;
      }
    },
    Get: {
      inp: { self: mt.Ptr(ElementArray), idx: t.Size },
      out: T, 
      def: () => {
.       assert(idx < self->size);
.       return self->data[idx];
      }
    },
    Set: {
      inp: { self: mt.Ptr(ElementArray), idx: t.Size, val: T },
      out: t.Nothing, 
      def: () => {
.       assert(idx < self->size);
.       self->data[idx] = val;
      }
    }
  },
  // We can't really define tests
  // in the Array metaclass since we don't know necessarily how to e.g. initialize
  // elements without knowing what their type will be.

  tests: {}
}}

defineMetaclass(ArrayMetaclass)

// Let's make an array of doubles just for testing. 
TestArray = mc.Array(t.Double)
TestArray.tests = {
  "DoubleArray_Create creates an array with the correct size": () => {
.   size_t size = 3;
.   int init_val = 0;
.   DoubleArray* arr = DoubleArray_Create(size, init_val);
.   assert(DoubleArray_GetSize(arr) == size);
.   DoubleArray_Destroy(&arr);
  },
  "DoubleArray_Create correctly initializes all values": () => {
.   size_t size = 3;
.   int init_val = 0;
.   DoubleArray* arr = DoubleArray_Create(size, init_val);
.   for (size_t i = 0; i < DoubleArray_GetSize(arr); ++i) {
.     assert(DoubleArray_Get(arr, i) == 0);
.   }
.   DoubleArray_Destroy(&arr);
  }
}

defineClass(TestArray)
