
ArrayListT = {
  name: "ArrayList", 
  name_fn: function(T) { return capitalize(T) + "ArrayList" },
}

ArrayListT.template = function(ElementType, elements_are_objects) { 
  var ClassName = ArrayListT.name_fn(ElementType)

  if (elements_are_objects) {
      ElementType = mt.Ptr(ElementType)
  }

  ElementArray = mt.Array(ElementType)

  return {
    name: ClassName,
    metadata: {
      project_deps: [ElementArray],
      external_deps: ["assert", "stdlib", "stdio"],
      external_libs: [] 
    },
    struct: {
      // Size of the array
      size: t.Size,
      // Elements of the array
      data: mt.Ptr(ElementArray)
    },
    constructor: {
      inp: { size: t.Size, init_value: ElementType },
      def: () => {
.       self->size = size;
.       self->data = @{ElementArray}_Create(size, init_value);
.       assert(self->data);
      }
    },
    destructor: () => {
.     @{ElementArray}_Destroy(&(self->data));
    },
    api: {
      GetSize: {
        inp: {},
        out: t.Size,
        def: () => {
.         return self->size;
        }
      },
      Get: {
        inp: { idx: t.Int },
        out: ElementType,
        def: () => {
.         assert(idx < self->size);
.         return @{ElementArray}_Get(self->data, idx);
        }
      },
      Set: {
        inp: { idx: t.Int, new_value: ElementType },
        out: t.Nothing,
        def: () => {
.         assert(idx >= 0);
.         assert(idx < self->size);
.         @{ElementArray}_Set(self->data, idx, new_value);
        }
      },
      Append: {
        inp: { value: ElementType },
        out: t.Nothing, 
        def: () => {
.         if (self->size == @{ElementArray}_GetSize(self->data)) {
            // Create new array twice as large as current one
.           @{mt.Ptr(ElementArray)} new_data = @{ElementArray}_Create(self->size * 2, 0);
            // Copy elements from old into new
.           for (int i = 0; i < @{ElementArray}_GetSize(self->data); ++i) {
.             @{ElementArray}_Set(new_data, i, @{ElementArray}_Get(self->data, i));
.           }
            // Destroy old
.           @{ElementArray}_Destroy(&self->data);
.           self->data = new_data; 
.         }
.         @{ElementArray}_Set(self->data, self->size, value);
.         ++self->size;
        }
      }
    },
    tests: {}
  }
}

defineMetaClass(ArrayListT)

IntArrayListT = mc.ArrayList(t.Int)
IntArrayListT.tests = {
    "Creating with size returns correct result for GetSize": () => {
.     size_t size = 2;
.     int init_value = 0;
.     IntArrayList *al = IntArrayList_Create(size, init_value);
.     assert(IntArrayList_GetSize(al) == size);
.     IntArrayList_Destroy(&al);
    },
    "Appending an element increases the size by 1": () => {
.     size_t init_size = 1;
.     int init_value = 0;
.     IntArrayList *al = IntArrayList_Create(init_size, init_value);
.     IntArrayList_Append(al, 2);
.     assert(IntArrayList_GetSize(al) == init_size + 1);
.     IntArrayList_Destroy(&al);
    },
    "Appending an element inserts the correct element to the end of the list": () => {
.     size_t init_size = 1;
.     int init_value = 0;
.     IntArrayList *al = IntArrayList_Create(init_size, init_value);
.     int value_to_insert = 2;
.     IntArrayList_Append(al, value_to_insert);
.     assert(IntArrayList_Get(al, IntArrayList_GetSize(al) - 1) == value_to_insert);
.     IntArrayList_Destroy(&al);
    }
}

defineClass(IntArrayListT)
